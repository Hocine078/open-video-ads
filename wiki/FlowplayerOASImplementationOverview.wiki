#summary An Overview of the Flowplayer Open Ad Streamer Design and Implementation
#sidebar TableOfContents

This document steps through the design and implementation of the Flowplayer Open Ad Streamer.

==Download the Code==

If you haven't downloaded the source code, do so [http://open-video-ads.googlecode.com/files/openvideoads.flowplayer.openadstreamer-0.2.1.tar.gz now]. We also recommend that you download the [http://open-video-ads.googlecode.com/files/openvideoads.vast.as3.tar.gz VAST AS3 Framework code] as this isn't packaged by default with the plug-in source. You'll need to refer to both as we step through the implementation.


==Check out the Examples==

Before stepping through the detailed design of the Flowplayer Open Ad Streamer it's worth taking the time to review the  [http://www.bouncingminds.com/plugins/flowplayer/openvideoads/openadstreamer/latest/examples/index.html 30 odd examples] that have been created to show how the Ad Streamer can be configured.

Each of these examples explores a different area of behavior for both the Ad Streamer and the VAST AS3 Framework. 


==A Bit About Flowplayer==

The Flowplayer Open Ad Streamer relies on Flowplayer 3.1.3 or greater. The implementation makes use of the new Flowplayer instream API to add mid-roll video ads mid-stream. 

There are several key features of Flowplayer that need to be considered when finalising a design to integrate the VAST AS3 Framework to deliver video advertising:

  # Flowplayer provides a specific API to manage 'time-based' events in the player. This API is known as the Cuepoint API. It allows a plugin to set a specifically labeled cuepoint event to occur at a nominated point in time. This API is perfectly crafted for use by the framework to help track the progress of video advertising as it is played. For more information on this API, please refer to this [http://www.flowplayer.org/documentation/api/clip.html#cuepoints flowplayer documentation].
  # The second key feature of Flowplayer is it's "instream" API. This API allows "child" streams to be inserted to play at a specific point within a parent clip. This API is perfect to support the delivery of mid-roll and non-linear (overlay) 'click to play a video' advertising. For more information on this API, please refer to this [http://www.flowplayer.org/demos/configuration/instream-playlist.html flowplayer documentation].
  # Finally, Flowplayer provides a good clip management API that allows a plugin to build up and management a specific playlist. This API is well suited to use by the framework to build up a sequence of advertising and show clips to play sequentially in the player. For more information on this API, please refer to this [http://www.flowplayer.org/apidoc flowplayer documentation].

All three API features influence the design and implementation of our Flowplayer Open Ad Streamer.


==Key Design Considerations==

When integrating the VAST AS3 Framework to create an Ad Streamer a number of important questions must be asked:

  # *Tracking Time*: How is the player going to notify the framework about changes to the stream timeline and how does it track that time - relative to the clip or the playlist? Will it send new time updates at a certain frequency or does it prefer to have specific time based events registered so that it can notify when the time has been hit? (for example, if we need to know when the stream is half way through, does the player prefer to tell us every 1/10th of second the latest time or does it prefer to notify the framework only at the time the stream is half way through?). In the case of Flowplayer it prefers to have time based events registered via the Cuepoint API whereas JW Player notifies every 10th of a second. In both cases, all time is reported relative to the start of the active clip (so when a new stream starts playing, time is reset to 0)
  # *Managing the Control Bar*: How does the player manage the control bar - for video advertising the seeker (timeline) needs to be disabled when video ads play - we need to know how to do that so that the appropriate code can be implemented when the framework notifies our new ad streamer when an ad starts or ends.
  # *Recognising User Inputs*: How does the player recognise when fullscreen has been activated, mute, start, stop, pause etc.? When these events occur, the VAST Framework needs to be notified so that it can log the event accordingly.
  # *Displaying Non-Linear Advertising*: How do you want to handle the display of overlay advertising? The VAST Framework can handle it, but it needs to be given a handle to an appropriate DisplayContainer for the player so that the overlay Sprites can be created, added and shown when required.
  # *Managing the Playlist*: Ultimately the goal of an Ad Streamer implementation is to manage the sequencing of video ads with show streams in such a way that the Player knows how to play the sequence. How does the player prefer to handle the sequencing of such a playlist? Does it prefer to deal with the resulting sequence as a playlist of a specific format (e.g. in the case of the JW Player Ad Streamer an XSPF Playlist which can just be read directly into the player via it's playlist load API, or in Flowplayer's case, the Playlist object in the player can be directly configured via the Playlist AS API)
  # *Managing the Streaming Providers*: How are the streaming protocol providers handled by the player?. For instance, how is RTMP supported by the player? Does a separate RTMP plugin have to be loaded or is it automatically available to the player?

All of these questions require careful consideration before finalizing the implementation approach for the Ad Streamer.

In the case of Flowplayer, the answers are as follows:

  # *Tracking time*: we will use the Flowplayer Cuepoint API and time is tracked relative to the Clip
  # *Managing the control bar*: using the plugin API to gain access to the control bar plugin
  # *Recognizing user inputs*: We are using the Flowplayer.on....() API (e.g. onMute(), onFullscreen() etc.) to identify when user input event occur
  # *Displaying Non-Linear Advertising*: We will rely on the VAST Framework to do that, and we'll provide a handle to the Flowplayer DisplayContainer and a set of DisplayProperties that inform the framework about the dimensions of the player
  # *Managing stream sequencing*: We will do that directly via the Flowplayer Playlist and instream() API
  # *Managing providers*: We will check for and load the appropriate streaming providers as required/specified by the ad streamer configuration


==High Level Design==

The following diagram illustrates the high level process that the Flowplayer Open Ad Streamer implements:

{insert diagram here}


==The Code==


===Example Configuration===

For the code walkthrough we will use [http://www.bouncingminds.com/plugins/flowplayer/openvideoads/openadstreamer/latest/examples/http-example03.html HTTP example 03] - a simple configuration that delivers a pre-roll ad before a show stream and then an overlay 5 seconds into the show stream that supports a "click to start a video ad".

The configuration for example03 is as follows:

{{{
flowplayer("a.example", "../dist/flowplayer-3.1.3-dev.swf", {
    plugins: {
        controls: {
            autoHide: "always"
        },

        openAdStreamer: {
            url: '../dist/OpenAdStreamer.swf',

            "deliveryType": "progressive",

            "shows": {
                 "streams": [  
                      { 
                          "file":"http://static.bouncingminds.com/shows/bbb_640x360.mp4", 
                          "duration":"00:00:30" 
                      } 
                 ]
            },

            "overlays": {
                 "regions": [
                      {
                           "id": "bottom",
                           "verticalAlign": "bottom",
                           "horizontalAlign": "center",
                           "backgroundColor": "#000000",
                           "width": 300,
                           "height": 40
                      }
                 ]
            },

            "ads": {
                 "server": {
                      "type": "OpenX",
                      "vastURL": "http://openx.bouncingminds.com/openx/www/delivery/fc.php"
                 },
                 "schedule": [
                      {
                           "zone": "5",
                           "position": "pre-roll"
                      },
                      {
                           "zone": "12",
                           "position": "bottom",
                           "width": 600,
                           "height": 40,
                           "startTime": "00:00:05",
                           "duration": "15"
                      }
                  ],
              },

              "debug": {
                  "levels": "all",
                  "debugger": "firebug"
              }
         }
    }
});
}}}

You will see in this configuration that we've declared our OpenAdStreamer plugin to Flowplayer and stated that the Control Bar is always to be hidden in the player (unless moused over).

The configuration for the OpenAdStreamer instance declares:

  * Our ad server is "OpenX" and is addressable on the "vastServerURL" specified
  * One stream to play - a HTTP stream for 30 seconds (http://static.bouncingminds.com/shows/bbb_640x360.mp4)
  * One pre-roll ad to play - identified as "zone 5" in our OpenX ad server instance
  * One region to be used for the display of overlay advertising - identified as region "bottom"
  * The overlay ad is to start 5 seconds into the show stream and last for 15 seconds
  * We will be using the Firebug console to view debug information and "all" debug messages are to be output

For a detailed description of all of the configuration parameters permitted by the Flowplayer Open Ad Streamer (and the VAST Framework), please refer to the [http://code.google.com/p/open-video-ads/wiki/OASConfiguration Configuration Guide].


===Initialising the Framework===

The first step to be taken to integrate the VAST framework is to instantiate it and configure the baseline operating condititions.

The framework has a master class known as the `VASTController`. To integrate the framework, an instance of this class must be instantiated and configured. Once complete, access to the framework is controlled through this class. The bulk of the public API for the framework is implemented by the `VASTController`.

The following code snippet has been taken from the Flowplayer Open Ad Streamer to illustrate how it fires up the VAST framework via the `VASTController`:

{{{
    // Load up the config and configure the framework
    _vastController = new VASTController();
    _vastController.setTimeBaseline(VASTController.RELATIVE_TO_CLIP);
    _vastController.trackStreamSlices = false;
    _vastController.startStreamSafetyMargin = 300; // needed because cuepoints at 0 for FLVs don't fire
    _vastController.initialise((new PropertyBinder(new Config(), null).copyProperties(_model.config) as Config));
    doLog("Flowplayer Open Video Ad Streamer constructed - build 0.1.1.1", Debuggable.DEBUG_ALL);
}}}

There are 4 separate calls made to get the framework up and into a working state:

  # `setTimeBaseline()` - this call tells the framework that time is measured relative to each clip playing. This means that when a new clip starts, the time that the player reports on the timeline is reset to 0 so all tracking events in the framework should be set relative to the clip being played.
  # `trackStreamSlices` - this is a slightly more complicated call and it relates specifically to how mid-roll ads are to be treated by the player - for Flowplayer it is set to `false` which means that the player is not interested in treating a stream "sliced" up by mid-roll ads as individual stream segments. Rather, it will view the show stream as one entire stream. This is possible because Flowplayer supports an API that allows streams to be inserted and played mid-stream without impacting the underlying parent stream. JW Player on the other hand does not support this type of API so the only way that a mid-roll ad can be accommodated is to physically slice a show stream into the part to play before the mid-roll ad and then the part after the mid-roll ad. If you look at the JW Player Open Ad Streamer initialisation code, you will see that `trackStreamSlices=true`
  # `startStreamSafetyMargin` is a call that allows the framework to treat timing events that are to occur at the start of a stream a little differently by offsetting the start time by the "milliseconds" value specified as `startStreamSafetyMargin`. For example, when an ad stream starts, the `started` tracking event is to be fired and subsequently recorded by the ad server. There are circumstances where time based events fired at a 0 point in time in the stream do not reliably fire because the player is busy starting up the stream. To be safe, those events are delayed for 300 milliseconds (in the case of the Flowplayer config above)
  # Finally then we get to the `initialise()` call - this is the call that allows the configuration data associated with the player and the framework to be read by the framework. Configuration data must always be passed to the `initialise()` call in the form of a well formed object. In the case of Flowplayer, the JSON configuration data can be placed directly into the `org.openvideoads.vast.config.Config` object (via the Flowplayer `PropertyBinder`). When the `VASTController` receives a `org.openvideoads.vast.config.Config` object it will just save it as is. If however it recieves a vanilla `Object`, it will interrogate that object to obtain the individual properties and will create a well formed `org.openvideoads.vast.config.Config` object as a result.

Once the `VASTController` receives the configuration data and has parsed it accordingly, it undertakes several vital steps required to prepare itself to make VAST Ad Server calls before processing the results into a readable form by the Video Player:

  # It constructs an `AdSchedule` based on the configuration data provided
  # It creates an instance of the appropriate Ad Server connection object so that it is ready to talk with the Ad Server when required 

The current version of the framework supports an Ad Server connection class for OpenX. 

An AdTech class is in the works along with a more generic VAST Router class that allows non VAST compliant ad servers to be bridged. 

The "server" configuration parameter (in the "ads" configuration grouping) identifies the type of VAST compliant Ad Server to which the framework will be communicating. In our example the "server" configuration appears as follows:

{{{
    "server": {
        "type": "OpenX",
        "vastURL": "http://openx.bouncingminds.com/openx/www/delivery/fc.php"
    },
}}}


===Constructing an AdSchedule===

An _Ad Schedule_ is a central construct within the VAST AS3 Framework and the Flowplayer Open Ad Server as a result. It is a series of Ad Slots that represent a single Video Ad instance to be played when the Video Player serves the streams.

An Ad Schedule is declared through the "schedule" configuration parameter within the "ads" configuration grouping. The declaration below is from our example 03:

{{{
                 "schedule": [
                      {
                           "zone": "5",
                           "position": "pre-roll"
                      },
                      {
                           "zone": "12",
                           "position": "bottom",
                           "width": 600,
                           "height": 40,
                           "startTime": "00:00:05",
                           "duration": "15"
                      }
                  ],
}}}

In this declaration, 2 _Ad Slots_ are declared - the first is a pre-roll ad identified as zone "5" in our OpenX instance, the second is a non-linear ad identified as Zone "12" to OpenX. The presence of "zones" allows each ad slot to be differentiated to the Ad Server.

When the framework (the `VASTController`) is initialised, the _Ad Schedule_ declared in the configuration data is transposed into an object model that is internally used to represent the Ad Schedule. The object model is headed by a class termed `AdSchedule` and it contains 1 to many `AdSlots`.

On initialisation the Ad Schedule is just an abstract definition of the Ads that are to be played by the Video Player.

Once the VAST Framework makes a call to an Ad Server and receives the corresponding VAST data back, the Ad Schedule is turned into an actual representation of the Video Ads to be played in each _Ad Slot_.

Consider our example 03. When the VAST Framework is initialised, the `AdSchedule` object model exists as illustrated below:

<img src="http://static.bouncingminds.com/images/open-video-ads/adschedule-model.png" border="0" height="340">
<br/>
<br/>
_*Figure 2: The Basic AdSchedule*_
<br/>

Following the load of the VAST data however, the object model expands to become:

<img src="http://static.bouncingminds.com/images/open-video-ads/adschedule-model-with-ads.png" border="0" height="340">
<br/>
<br/>
_*Figure 3: The Populated AdSchedule*_


For a detailed explanation of what happens when an Ad Server call is made and a VAST response is parsed by the framework, read the section further on in this guide entitled "Requesting a Video Ad Serving Template (VAST) from the Ad Server".

===Make sure that the Streaming Providers are Loaded===

Once the VAST Framework is initialised, the next step taken is to ensure that the required "providers" are loaded ready to play the streams once they are configured in the player. Flowplayer implements additional streaming providers (e.g. RTMP, secure RTMP, pseudo-streaming etc.) as separate provider plugins.

The following code asks the `VASTController` whether or not a provider definition for "rtmp" has been specified in the config - if it has then a call is made to ensure that the RTMP plugin is loaded before going any further.

{{{
    if(_vastController.hasProvider("rtmp")) {
         ensureProviderPluginLoaded("rtmp", "rtmp");
    }

    ..... 

    _player.loadPlugin(providerName, providerUrl, onProviderLoaded);
}}}


===Managing Player Events===

The next step in the initialisation process is to create the handlers to deal with user related events. 

When the player is playing users can:

  * Go fullscreen
  * Hit the mute button
  * Change the volume controls

If any of these actions are taken during an ad play, the VAST Framework needs to know that they have been occurred so that the appropriate ad tracking calls can be made.

The following code sets up the handlers for Flowplayer.

{{{
    // Setup the player tracking events
    _player.onFullscreen(onFullScreen);
    _player.onFullscreenExit(onFullScreenExit);
    _player.onMute(onMuteEvent);
    _player.onUnmute(onUnmuteEvent);
    _player.onVolume(onProcessVolumeEvent);  
}}}

If we look at the "fullscreen" handler `onFullScreen()`, we will see how the VAST framework is notified that the event has occurred.

{{{
    private function onFullScreen(playerEvent:PlayerEvent):void {
        if(_vastController != null) _vastController.onPlayerResize(_player.playlist.currentIndex);
    }
}}}

When the player goes "fullscreen", the `_vastController` is informed via the `onPlayerResize()` API. The current index of the stream must be passed into that call so that the VAST Controller knows which stream has been impacted by the fullscreen action.

For a complete description of the "Player Event" related `VASTController` APIs,  please refer to the [VASTAS3FrameworkPlayerEvents "Managing Player Events Guide"].

For a full account of the ad tracking supported by the VAST framework, refer to the [VASTAS3FrameworkAdTracking Ad Tracking Guide].


===Configure the Key Event Listeners===

The VAST framework notifies a player implementation of changes in the framework via the Actionscript Event dispatcher/listener mechanism.

Listeners can be identified for a range of events.

The following code snippet from the Flowplayer Open Ad Streamer illustrates how to register and listen for all of the events broadcast by the framework.

{{{
    // Setup the critical listeners for the template loading process
    _vastController.addEventListener(TemplateEvent.LOADED, onTemplateLoaded);
    _vastController.addEventListener(TemplateEvent.LOAD_FAILED, onTemplateLoadError);

    // Setup the linear ad listeners
    _vastController.addEventListener(LinearAdDisplayEvent.STARTED, onLinearAdStarted);
    _vastController.addEventListener(LinearAdDisplayEvent.COMPLETE, onLinearAdComplete); 
    _vastController.addEventListener(LinearAdDisplayEvent.CLICK_THROUGH, onLinearAdClickThrough);           
           
    // Setup the companion display listeners
    _vastController.addEventListener(CompanionAdDisplayEvent.DISPLAY, onDisplayCompanionAd);
    _vastController.addEventListener(CompanionAdDisplayEvent.HIDE, onHideCompanionAd);

    // Decide how to handle overlay displays - if through the framework, turn it on, otherwise register the event callbacks
    _vastController.enableNonLinearAdDisplay(new DisplayProperties(this, 640, 360, 25));
    _vastController.addEventListener(OverlayAdDisplayEvent.DISPLAY, onDisplayOverlay);
    _vastController.addEventListener(OverlayAdDisplayEvent.HIDE, onHideOverlay);
    _vastController.addEventListener(OverlayAdDisplayEvent.DISPLAY_NON_OVERLAY, onDisplayNonOverlay);
    _vastController.addEventListener(OverlayAdDisplayEvent.HIDE_NON_OVERLAY, onHideNonOverlay);
    _vastController.addEventListener(OverlayAdDisplayEvent.CLICKED, onOverlayClicked);
    _vastController.addEventListener(AdNoticeDisplayEvent.DISPLAY, onDisplayNotice);
    _vastController.addEventListener(AdNoticeDisplayEvent.HIDE, onHideNotice);
          
    // Setup the hander for tracking point set events
    _vastController.addEventListener(TrackingPointEvent.SET, onSetTrackingPoint);
    _vastController.addEventListener(TrackingPointEvent.FIRED, onTrackingPointFired);
            
    // Setup the hander for display events on the seeker bar
    _vastController.addEventListener(SeekerBarEvent.TOGGLE, onToggleSeekerBar);
            
    // Ok, let's load up the VAST data from our Ad Server - when the stream sequence is constructed, register for callbacks
    _vastController.addEventListener(StreamSchedulingEvent.SCHEDULE, onStreamSchedule);
    _vastController.addEventListener(NonLinearSchedulingEvent.SCHEDULE, onNonLinearSchedule);
}}}

Broadly speaking there are 5 categories of events:

  # Data loading events:
    * VAST data loading (`TemplateEvent`)
  # Ad display events:
    * Linear ad display events (`LinearAdDisplayEvent`)
    * Companion Ad display events (`CompanionAdEvent`)
    * Non-Linear Ad display events (`OverlayAdDisplayEvent`)
    * Ad Notice display events (`AdNoticeDisplayEvent`)
  # Ad and Stream Scheduling events
    * Stream scheduling events (`StreamSchedulingEvent`)
    * Non-linear ad (Overlay) scheduling events (`NonLinearSchedulingEvent')
  # Time tracking events
    * Tracking point events (`TrackingPointEvent`)
  # Player control events:
    * Control bar (seeker) action events (`SeekerBarEvent`)

For a detailed description of all event types, please refer to the "[VASTAS3FrameworkEventManagement Event Management Guide]".

The critical events for the Flowplayer Open Ad Streamer are:

  * The data loading events (`TemplateEvent.LOADED`) so that the plugin knows when the VAST data requested from the Ad Server has been successfully returned
  * The Ad and Stream scheduling events (`StreamSchedulingEvent.SCHEDULE` and `NonLinearSchedulingEvent.SCHEDULE`) because the plugin creates the player playlist based on notifications back from the framework that a stream is to be scheduled for playback
  * The companion ad display events as the Flowplayer plugin then facilitates the display of those companions in the page containing the player
  * Non-linear Ad display events (specifically `OverlayDisplayEvent.CLICKED`) so that the plugin can trigger an instream video ad to be played where required
  * Player control events (`SeekerBarEvent.TOGGLE`) to allow the scrubber bar to be enabled/disabled when linear ads are played


===Requesting a Video Ad Serving Template (VAST) from the Ad Server===

Once the VAST Framework has been instantiated and configured via the `VASTController`, a request can be made to obtain the Video Ad Serving Template (VAST) data from the VAST compliant ad server.

The following code snippet illustrates how that is done in the Flowplayer Open Ad Streamer:

{{{
    _vastController.load();	

    ....

    protected function onTemplateLoaded(event:TemplateEvent):void {
        doLogAndTrace("NOTIFICATION: VAST data loaded - ", event.template, Debuggable.DEBUG_FATAL);
        _player.playlist.replaceClips2(_clipList);
        _model.dispatchOnLoad();
    }
}}}

The call to the ad server is triggered via the `VASTController.load()` API. 

When called, the VASTController constructs a request for the specified Ad Server, fires it off to the ad server, waits for a response (which should be the VAST data), processes the response, constructs an object model representing the VAST ad data before calling back the Flowplayer Open Ad Streamer call via the method listening for the `TemplateEvent.LOADED` event.

A `VideoAdServingTemplate` can be obtained from the `TemplateEvent` via the `TemplateEvent.template` attribute.

In between constructing the original ad server request and the dispatch of the `TemplateEvent.LOADED` event, a lot of processing occurs within the VAST framework.

The three key activities undertaken by the framework during this period are:

  # The formation of the ad server request
  # The parsing of the VAST response to create a `VideoAdServingTemplate`
  # The mapping of the Ads in the `VideoAdServingTemplate` to the `AdSchedule`
  # The construction of a `StreamSequence` based on the shows configuration and the streams identified in the `AdSchedule`
  # The dispatching and processing of Ad and Stream scheduling events back to the Flowplayer Open Ad Streamer plugin

====The Formation of the Ad Server Request====

A VAST request to an ad server will vary according to the ad server brand.

For our example03 and OpenX, a VAST request takes the following form:

{{{
    http://openx.openvideoads.com/openx/www/delivery/fc.php
                   ?script=bannerTypeHtml:vastInlineBannerTypeHtml:vastInlineHtml
                   &zones=pre-roll0-0%3D5%7Cbottom1-0%3D12&nz=1
                   &source=
                   &r=3189404.425211251
                   &block=1
                   &format=vast
                   &charset=UTF_8
}}}

There are 2 key parameters in that call:

  # "zones" - identifies the number and type of ads requested
  # "block" - identifies whether or not ads can be repeated in the matching across the returned set
  # An optional set of ad matching criteria to allow targeted ad selection on the OpenX side

If the configuration for the player/framework includes the parameter `"allowAdRepetition:true"`, then the "block" value will be set to "0" - this tells OpenX that the same ad may be returned multiple times across the response. By default it is set to "1" which means that every ad returned in the request block must be unique. If we had 3 pre-roll ads to serve in 1 go, that would be important.

"Matching" or "targetting" criteria is declared in the player/framework configuration using the `"selectionCriteria:` flag. This parameter is declared as an array of "key, value" pairs. For example, if we wished to limit the ad selection to "males 25 to 30", we may declare the `selectionCriteria` in our configuration as:

{{{
    "selectionCriteria": [ { "sex": "male" }, { "age:", "25-30" } ]
}}}

When the call is made to OpenX, the following values would be added to the call:

{{{
     &sex=male&age=25-30
}}}

See [http://www.bouncingminds.com/plugins/flowplayer/openvideoads/openadstreamer/latest/examples/http-example20.html HTTP example20] for a worked example using the Flowplayer Open Ad Streamer.

The "zones" parameter is the more complex of the parameters. It has to effectively identify:

  * The number of ads requested
  * The type of each ad requested
  * A unique identifier for each ad requested

In our example the "zones" parameter value is `zones=pre-roll0-0%3D5%7Cbottom1-0%3D12`

Breaking this example down into it's parts:

  * There are two ads to be identified
  * The first ad is of OpenX zone type "5" (as defined by our first Ad Slot)
  * The second ad is of OpenX zone type "12" (as defined by our second Ad Slot)
  * The first ad has a unique identifier 'pre-roll0-0"
  * The second ad has a unique identifier 'bottom1-0"

While the unique identifies for each ad zone are irrelevant for the OpenX server, they are very important for the Open Ad Streamer and the AS3 Framework.

Because multiple ads are being requested in a single call, the framework needs to be able to uniquely identify which ad maps back to which Ad Slot when the VAST response from the Ad Server is parsed by the framework.

When the framework makes a request to an ad server, it generates a unique identifier for each ad slot and requires that the identifier is passed back in the VAST response unchanged so that this mapping can be completed.

Below is a cut-down example VAST response for our OpenX ad call - you can see how the unique identifiers are provided in the response:

{{{
<VideoAdServingTemplate xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="vast.xsd">
    <Ad id="pre-roll0-0" >        
        <InLine>            
            <AdSystem>openx</AdSystem>                
            <AdTitle>
                   <![CDATA[HTTP - Heinz Mayo Video (30 secs)]]>
            </AdTitle> 
              .....             
         </InLine>
     </Ad>
    <Ad id="bottom1-0" >        
         <InLine>            
             <AdSystem>openx</AdSystem>                
             <AdTitle> 
                   <![CDATA[HTTP OVERLAY - click to video]]>
             </AdTitle>       
              .....             
        </InLine>
    </Ad>
</VideoAdServingTemplate>
}}}


====The Parsing of the Ad Server Response====

Upon the receipt of a VAST response from the ad server, the framework constructs an object model of the Video Ad Serving Template.

You can see an example VAST response for our example03 [http://openx.bouncingminds.com/openx/www/delivery/fc.php?script=bannerTypeHtml:vastInlineBannerTypeHtml:vastInlineHtml&zones=pre-roll0-0%3D5|bottom1-0%3D12&nz=1&source=&r=3189404.425211251&block=1&format=vast&charset=UTF_8 here] (if you can't see the response correctly in your browser, copy the link and cut and paste it into Firefox to view).

At a high level, the object model is constructed as follows:

  * A single `VideoAdServingTemplate` is instantiated
  * For each Ad returned in the VAST data, a `VideoAd` object is instantiated and added to the list held by the `VideoAdServingTemplate`
  * A `VideoAd` encapsulates the definition of the entities that are to be played for a single `AdSlot` in the `AdSchedule`. These may be:
    * A `LinearVideoAd` or
    * A `NonLinearVideoAd` that may optionally have a `LinearVideoAd` attached to it (if it's an overlay that triggers a video ad to play)
    * Both `LinearVideoAds` and `NonLinearVideoAds` may have `CompanionAds` attached
  * If a `LinearVideoAd` is created, a number of `MediaFiles` may be attached to that `LinearVideoAd` - each `MediaFile` represents a specific type of video stream that may be played (mimeType, bitrate, streaming or progressive etc.)

For a detailed view of the class model associated with the framework, please review the [VASTAS3FrameworkClassModel Framework Class Model Guide].

====The Construction of a Stream Sequence====

With a `VideoAdServingTemplate` successfully constructed, the next step the framework takes in a `VASTController.load()` is to map the object model behind the `VideoAdServingTemplate` to the `AdSchedule` object model constructed when the framework was initialised.

There is a one-to-one correlation between the ads returned in the VAST response (and held in the `VideoAdServingTemplate`) and the `AdSlots` held in the `AdSchedule`.

Figure 3 (above) illustrates what the AdSchedule object model looks like once it's been populated with the results of a VAST ad server request.

But the mapping of VAST ads to the actual `AdSchedule` is only part of the picture.

To have a complete picture of what is to be played by the player a `StreamSequence` must be constructed.

A `StreamSequence` is a sequential list of `Streams` that are to be played one after each other by the Video Player.

A `Stream` can be either a show `Stream` or an `AdSlot`.

For example, in example03 we have 2 streams that are to be played:

  # A pre-roll linear video ad followed by
  # A show stream

The `StreamSequence` would therefore contain 2 `Streams` - the first `AdSlot` and the second show `Stream`.

A `StreamSequence` can be converted to a playlist. This is particularly useful if the Video Player accepts playlists of certain formats. Once the VAST response has been parsed and the `StreamSequence` formed, a simple call to the `VASTController` can return a specifically formatted playlist (e.g. an XSPF playlist for instance). For a full description of the VASTController playlist API and the various playlist formats returned, please refer to the "[VASTAS3FrameworkPlaylists Playlist Guide]".

The Flowplayer Open Ad Streamer does not use playlists however. It directly constructs the internal Flowplayer playlist by parsing the `StreamSequence` object model. Each `Stream` in the sequence represents a Flowplayer `Clip` that is to be added to the Flowplayer `Playlist` object.

A `StreamSequence` and an `AdSchedule` share an important relationship.

The following diagram illustrates the object model that exists for our Example03 once the `StreamSequence` has been formed. It also identifies the relationships that exist between the `StreamSequence`, the `VideoAdServingTemplate` and the `AdSchedule`.

<img src="http://static.bouncingminds.com/images/open-video-ads/adschedule-streamsequence-model.png" border="0" height="390">
<br/>
<br/>
_*Figure 4: A StreamSequence and AdSchedule working together*_


When the framework constructs a `StreamSequence`, it assesses:

  * The "ad schedule" defined in the configuration data
  * The "shows" configuration

to determine the order in which ads and show streams are to play.

In our example03, the result is quite straight forward - one ad plays first followed by the show stream. The resulting `StreamSequence` is then quite straight forward.

Consider however, a more complex example. [http://www.bouncingminds.com/plugins/flowplayer/openvideoads/openadstreamer/latest/examples/http-example05.html Example05] has a pre-roll being served before a show stream, a mid-roll ad 10 seconds into the show stream followed by a post-roll ad at the end.

The configuration snippet from below is from Example05:

{{{
    "shows": {
        "baseURL": "http://static.bouncingminds.com/shows",
        "streams": [
            { "file":"bbb_640x360.mp4", "duration":"00:01:00" }
        ]
    },

    "ads": {
        "server": {
            "type": "OpenX",
            "vastURL": "http://openx.bouncingminds.com/openx/www/delivery/fc.php"
        },
        "schedule": [
            {
                "zone": "5",
                "position": "pre-roll",
                "playOnce": true
            },
            {
                "zone": "5",
                "position": "mid-roll",
                "startTime": "00:00:10",
                "playOnce": true
            },
            {
                "zone": "5",
                "position": "post-roll",
                "playOnce": true
            }
        ]
    },
}}}

The following diagram illustrates the `AdSequence` and `ShowSequence` that result from interpreting the ad schedule and show configuration:

<img src="http://static.bouncingminds.com/images/open-video-ads/adschedule-streamsequence-example05.png" border="0" height="230">
<br/>
<br/>
_*Figure 4: Example05 - Ad and Stream Sequences*_


The `StreamSequence` ends up having 5 streams defined in it:

  # The pre-roll ad slot
  # The first part of the show stream covering the first 10 seconds up to the start of the mid-roll ad
  # The mid-roll ad slot
  # The remaining show stream from 10 seconds to the end
  # The post-roll ad slot

Now you may remember when the VAST framework was initialised, there was a call made to the `VASTController` to set`trackStreamSlices` to `false`;

{{{
_vastController.trackStreamSlices = false;
}}}

That call directly impacts the way the `StreamSequence` is formulated.

Because Flowplayer allows mid-roll child streams (e.g. a mid-roll ad) to be directly inserted into a parent (e.g. show) stream via the Flowplayer "instream" API. For this reason, there is no need for the framework to "slice" up show streams into pieces so that each individual pre and post stream segment can be treated as an individual clip in a playlist. JW Player on the other hand doesn't have this type of API, so a playlist that has a mid-roll ad needs to have the show streams containing the mid-roll ad "sliced" into pieces.

===Ad Tracking and Flowplayer Cuepoints===

{{{
    protected function processCuepoint(clipevent:ClipEvent):void {
        var cuepoint:Cuepoint = clipevent.info as Cuepoint;
        var streamIndex:int = parseInt(cuepoint.callbackId.substr(3));
        var eventCode:String = cuepoint.callbackId.substr(0,2);
        doLog("Cuepoint triggered " + clipevent.toString() + " - id: " + cuepoint.callbackId, Debuggable.DEBUG_CUEPOINT_EVENTS);
        _vastController.processTimeEvent(streamIndex, new TimeEvent(clipevent.info.time, 0, eventCode));            	            
    }
}}}


===Turning the Control Bar On and Off===

When the framework was initialised, the Flowplayer Open Ad Streamer registered a listener (`onToggleSeekerBar()`) for the `SeekerBarEvent.TOGGLE` event.

The following code snippet is the `onToggleSeekerBar()` function:

{{{
    public function onToggleSeekerBar(event:SeekerBarEvent):void {
        if(_vastController.disableControls) {
            ....
            // CODE TO TURN OFF THE SCRUBBER
        }
    }
}}}

When a linear ad starts to play as well as when it ends, listeners to the `SeekerBarEvent.TOGGLE` event receive notification that the event has occurred. A call to `event.turnOff()` indicates whether or not the seeker bar should be disabled.

In the case of the Flowplayer Open Ad Streamer, `onToggleSeekerBar()` then grabs a handle to the control bar plugin and toggles it's enabled state accordingly.

===Displaying Companion Ads===

The Flowplayer Ad Streamer has registered via the `CompanionAdDisplayEvent.DISPLAY` event to receive notifications when the framework determines that a Companion Ad is to be displayed with either a Linear or Non-Linear ad.

To see companion ads in action, take a look at [http://www.bouncingminds.com/plugins/flowplayer/openvideoads/openadstreamer/latest/examples/http-example07.html Example 07].

To display a companion ad, the Flowplayer Ad Streamer utilises the Flash `ExternalInterface` call to push the companion ad content directly into the "div" blocks identified in the plugin configuration.

For example 07, the companion related configuration appears as follows within the "ads" configuration grouping:

{{{
    "displayCompanions": true,
    "companions": [
         { "id":"companion", "width":150, "height":360 }
    ],
}}} 

This configuration tells the framework to enable the display of companion banners and that the companion banners are to be displayed in a DIV block with the `id` "companion". The div block is sized 150 by 360 pixels. The framework will search through the companions provided in the `VideoAdServingTemplate` for one that size. Multiple companions can be specified allowing companions of different size to be placed around the player in different DIV blocks. 

The following code snippet is from the Flowplayer Ad Streamer - this is the code that responds to the "companion display" event saving the current content of the companion DIV block before the companion HTML is pushed into the DIV.

{{{
    public function onDisplayCompanionAd(companionEvent:CompanionAdDisplayEvent):void {
        _previousDivContent = new Array();
        if(companionEvent.contentIsHTML()) {
	    var previousContent:String = ExternalInterface.call("function(){ return document.getElementById('" + companionEvent.divID + "').innerHTML; }");
            _previousDivContent.push({ divId: companionEvent.divID, content: previousContent } );
            ExternalInterface.call("function(){ document.getElementById('" + companionEvent.divID + "').innerHTML='" + StringUtils.replaceSingleWithDoubleQuotes(companionEvent.content) + "'; }");
        }
        else {
             //TO IMPLEMENT isImage(), isFlash(), isText()
        }
    }
}}}

There is a corresponding function that gets executed when the "companion hide" event is fired to allow the original content of the companion DIV to be restored.

===Displaying Non-Linear (Overlay) Ads===

One of the advantages of the VAST framework is that it can take care of the display of non-linear (overlay) advertising for the Video Player. The Flowplayer Ad Streamer makes use of this.

To turn on control of the non-linear advertising, the Ad Streamer makes the following call to the `VASTController`

{{{
    _vastController.enableNonLinearAdDisplay(new DisplayProperties(this, 640, 360, 25));
}}}

This call requires a` DisplayProperties` object to be passed into the `VASTController`. The `DisplayProperties` instance defines the size of the player and a reference to the player's DisplayContainer so that the overlay `Sprite` can be added to the display container and shown.

[http://www.bouncingminds.com/plugins/flowplayer/openvideoads/openadstreamer/latest/examples/http-example19.html Example 19] is a good illustration of how overlays can be configured in the framework and displayed. Part of the configuration for example 19 is presented below:

{{{
    "overlays": {
        "regions": [
            {
                 "id": "bottom-center",
                 "contentTypes": "html",
                 "verticalAlign": "bottom",
                 "horizontalAlign": "center",
                 "backgroundColor": "#000000",
                 "opacity": 0.8,
                 "borderRadius": 15,
                 "width": 300,
                 "height": 40
           }
        ],
    }
    "ads": {
        "server": {
            "type": "OpenX",
            "vastURL": "http://openx.bouncingminds.com/openx/www/delivery/fc.php",
            "allowAdRepetition": true
        },
        "schedule": [
            {   
                  "zone": "3",
                  "position": "bottom-center",
                  "width": 600,
                  "height": 40,
                  "startTime": "00:00:02",
                  "duration": "5"
            }
        ]
    }
}}}

Overlay configuration have 2 aspects to them:

  * The definition of custom "regions" on the player screen that allow non-linear advertising to be displayed. All regions are assigned a specific "id" so that they may be uniquely named in an ad schedule.
  * The definition of the non-linear ad slots that are to be shown in a "region" identified with a specific "id"

For a detailed description of how to configure regions, please refer to the [VASTAS3FrameworkConfiguration Configuration Guide].

Although it doesn't make use of then, the Flowplayer Open Ad Streamer does register listeners for overlay display and hide events.

The following initialisation code illustrates how listeners for these events are registered:

{{{
    _vastController.addEventListener(OverlayAdDisplayEvent.DISPLAY, onDisplayOverlay);
    _vastController.addEventListener(OverlayAdDisplayEvent.HIDE, onHideOverlay);
}}}

The "display" event is fired when the framework determines that the overlay is to be shown while the "hide" is fired when the overlay is to be removed. The framework fires these events regardless of whether or not it is responsible for the display and hiding of overlays on the player. 

===Supporting Non-Linear (Overlay) 'Click to play a Video Ad'===

Non-linear advertising that supports the notion of "click me to start a video ad" has to be treated slightly differently by the Flowplayer Open Ad Streamer than standard display or "click through to a website" overlays.

The key difference is that a non-linear overlay that allows a video to be played in essence has a linear ad attached to it. From the perspective of the Flowplayer Open Ad Streamer, when the user clicks on an overlay to fire up the video, the player must insert the Video Ad "instream" to the current show clip.

As such, the Ad Streamer captures the overlay "click" event via the `OverlayAdDisplayEvent.CLICKED` event listener and processes it accordingly.

The following code snippet is from the Ad Streamer and is responsible for processing the click event on the overlay.

{{{
    public function onOverlayClicked(displayEvent:OverlayAdDisplayEvent):void {
        doLog("NOTIFICATION: Event received - overlay has been clicked!", Debuggable.DEBUG_DISPLAY_EVENTS);
        if(displayEvent.ad.hasAccompanyingVideoAd()) {
            var clip:ScheduledClip = new ScheduledClip();
	    var overlayAdSlot:AdSlot = _vastController.adSchedule.getSlot(displayEvent.adSlotKey);
				
	    clip.type = ClipType.fromMimeType(overlayAdSlot.mimeType);
	    clip.autoPlay = _vastController.config.playContiguously;
	    clip.start = 0;
	    clip.originalDuration = overlayAdSlot.getAttachedLinearAdDurationAsInt();
	    clip.duration = clip.originalDuration;

	    if(overlayAdSlot.isRTMP()) {
                clip.url = overlayAdSlot.streamName;
                clip.setCustomProperty("netConnectionUrl", overlayAdSlot.baseURL);
                clip.provider = "rtmp";          	
            }
            else {
	        clip.url = overlayAdSlot.url;
		clip.provider = "http";
            }

            // Setup the flowplayer cuepoints based on the tracking points defined for this 
            // linear ad (including companions attached to linear ads)

            clip.onCuepoint(processPopupVideoAdCuepoint);
	    var trackingTable:TrackingTable = overlayAdSlot.getTrackingTable();
	    for(var i:int=0; i < trackingTable.length; i++) {
	        var trackingPoint:TrackingPoint = trackingTable.pointAt(i);
		if(trackingPoint.isLinear()) {
		    clip.addCuepoint(new Cuepoint(trackingPoint.milliseconds, trackingPoint.label + ":" + displayEvent.adSlotKey));
		}
	    }
            _player.playInstream(clip);
        }
    }
}}}

Reviewing the code snippet there are a few interesting things to note about the way the Flowplayer Ad Streamer uses the VAST Framework:

  * The model objects (in this case a `NonLinearVideoAd`) can be extracted directly from the events that are fired back to the listeners - as illustrated by the code `displayEvent.ad`. Once a model object has been obtained, calls can be made directly to the model to find out information about it. In this case the Ad Streamer needs to know if there is a Linear Video Ad attached to the Non-Linear overlay - if there is, then it needs to be played.
  * To configure a clip to play, various pieces of information are required about - what protocol is to be used (RTMP or HTTP), what's the name of the stream and the file type - all of this information is available in the `AdSlot` corresponding to the overlay that was clicked. To get hold of the `AdSlot`, a call can be made to the `VASTController` to `getSlot()` at a specific index (identified as the `adSlotKey` attribute provided in the `OverlayAdDisplayEvent`). 
  * The ad tracking cuepoints for overlay 'click to play video' ads aren't setup by default by the `VASTController` when the ads are original sequenced and scheduled. Before the 'click to play' overlay video ad is fired up, the tracking cuepoints must be setup. The tracking points can be obtained from the AdSlot holding the overlay ad as the tracking table for that AdSlot will understand that it has a linear ad attached to the overlay and as such, will define the cuepoints necessary to track that ad when played. To make sure that only linear video ad tracking points are set in the player as the overlay video ad plays, the condition `if(trackingPoint.isLinear())` is used when setting the Flowplayer cuepoints.
  * Finally, the Flowplayer Ad Streamer uses the "instream" API to insert the newly formed video ad clip into the parent show stream. Once the clip has played, the original show stream resumes.

===Ensuring a Linear Ad plays only once===

{{{
    protected function onTrackingPointFired(event:TrackingPointEvent):void {
        _player.playlist.onFinish(
	    function(clipevent:ClipEvent):void {
	        var currentClip:ScheduledClip = _player.currentClip as ScheduledClip;
		if(!_playedOnce && _vastController.playOnce && !currentClip.marked) {
                    currentClip.marked = true;
		    // Manage the playlist so that ads are not replayed
	 	    if(_vastController.streamSequence.streamAt(_player.playlist.currentIndex) is AdSlot) {
                        // don't add it to the replay list
	 	    }
	 	    else _replayClipList.push(_player.currentClip);
	 						
	 	    if(_player.playlist.currentIndex == _player.playlist.length-1) {
                        // we are at the last item to be played so reload the cliplist
	 		_clipList = _replayClipList
	 		_playedOnce = true;
	 		_replayClipList = new Array();
	 		if(_clipList.length > 0) _clipList[0].autoPlay = false; 
	 		_player.playlist.replaceClips2(_clipList);
                    }			        		
               }
           }
       );
    }
}}}