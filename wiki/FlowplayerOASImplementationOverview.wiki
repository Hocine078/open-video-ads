#summary An Overview of the Flowplayer Open Ad Streamer Design and Implementation
#sidebar TableOfContents

This document will step through the design and implementation of the Flowplayer Open Ad Streamer.

==Download the Code==

If you haven't downloaded the source code, do so [http://open-video-ads.googlecode.com/files/openvideoads.flowplayer.openadstreamer-0.2.1.tar.gz now]. We also recommend that you download the [http://open-video-ads.googlecode.com/files/openvideoads.vast.as3.tar.gz VAST AS3 Framework code] as this isn't packaged by default with the plug-in source. You'll need to refer to both as we step through the implementation.

==Check out the Examples==

Before stepping through the detailed design of the Flowplayer Open Ad Streamer it's worth taking the time to review the  [http://www.bouncingminds.com/plugins/flowplayer/openvideoads/openadstreamer/latest/examples/index.html 30 odd examples] that have been created to show how the Ad Streamer can be configured.

Each of these examples explores a different area of behavior for both the Ad Streamer and the VAST AS3 Framework. 

==A Bit About Flowplayer==

The Flowplayer Open Ad Streamer relies on Flowplayer 3.1.3 or greater. The implementation makes use of the new Flowplayer instream API to add mid-roll video ads mid-stream. 

There are several key features of Flowplayer that need to be considered when finalising a design to integrate the VAST AS3 Framework to deliver video advertising:

  # Flowplayer provides a specific API to manage 'time-based' events in the player. This API is known as the Cuepoint API. It allows a plugin to set a specifically labeled cuepoint event to occur at a nominated point in time. This API is perfectly crafted for use by the framework to help track the progress of video advertising as it is played. For more information on this API, please refer to this [http://www.flowplayer.org/documentation/api/clip.html#cuepoints flowplayer documentation].
  # The second key feature of Flowplayer is it's "instream" API. This API allows "child" streams to be inserted to play at a specific point within a parent clip. This API is perfect to support the delivery of mid-roll and non-linear (overlay) 'click to play a video' advertising. For more information on this API, please refer to this [http://www.flowplayer.org/demos/configuration/instream-playlist.html flowplayer documentation].
  # Finally, Flowplayer provides a good clip management API that allows a plugin to build up and management a specific playlist. This API is well suited to use by the framework to build up a sequence of advertising and show clips to play sequentially in the player. For more information on this API, please refer to this [http://www.flowplayer.org/apidoc/flowplayer documentation].

All three API features influence the design and implementation of our Flowplayer Open Ad Streamer.

==Key Design Considerations==

When integrating the VAST AS3 Framework to create an Ad Streamer a number of important questions must be asked:

  # *Tracking Time*: How is the player going to notify the framework about changes to the stream timeline and how does it track that time - relative to the clip or the playlist? Will it send new time updates at a certain frequency or does it prefer to have specific time based events registered so that it can notify when the time has been hit? (for example, if we need to know when the stream is half way through, does the player prefer to tell us every 1/10th of second the latest time or does it prefer to notify the framework only at the time the stream is half way through?). In the case of Flowplayer it prefers to have time based events registered via the Cuepoint API whereas JW Player notifies every 10th of a second. In both cases, all time is reported relative to the start of the active clip (so when a new stream starts playing, time is reset to 0)
  # *Managing the Control Bar*: How does the player manage the control bar - for video advertising the seeker (timeline) needs to be disabled when video ads play - we need to know how to do that so that the appropriate code can be implemented when the framework notifies our new ad streamer when an ad starts or ends.
  # *Recognising User Inputs*: How does the player recognise when fullscreen has been activated, mute, start, stop, pause etc.? When these events occur, the VAST Framework needs to be notified so that it can log the event accordingly.
  # *Displaying Non-Linear Advertising*: How do you want to handle the display of overlay advertising? The VAST Framework can handle it, but it needs to be given a handle to an appropriate DisplayContainer for the player so that the overlay Sprites can be created, added and shown when required.
  # *Managing the Playlist*: Ultimately the goal of an Ad Streamer implementation is to manage the sequencing of video ads with show streams in such a way that the Player knows how to play the sequence. How does the player prefer to handle the sequencing of such a playlist? Does it prefer to deal with the resulting sequence as a playlist of a specific format (e.g. in the case of the JW Player Ad Streamer an XSPF Playlist which can just be read directly into the player via it's playlist load API, or in Flowplayer's case, the Playlist object in the player can be directly configured via the Playlist AS API)
  # *Managing the Streaming Providers*: How are the streaming protocol providers handled by the player?. For instance, how is RTMP supported by the player? Does a separate RTMP plugin have to be loaded or is it automatically available to the player?

All of these questions require careful consideration before finalizing the implementation approach for the Ad Streamer.

In the case of Flowplayer, the answers are as follows:

  # *Tracking time*: we will use the Flowplayer Cuepoint API and time is tracked relative to the Clip
  # *Managing the control bar*: using the plugin API to gain access to the control bar plugin
  # *Recognizing user inputs*: We are using the Flowplayer.on....() API (e.g. onMute(), onFullscreen() etc.) to identify when user input event occur
  # *Displaying Non-Linear Advertising*: We will rely on the VAST Framework to do that, and we'll provide a handle to the Flowplayer DisplayContainer and a set of DisplayProperties that inform the framework about the dimensions of the player
  # *Managing stream sequencing*: We will do that directly via the Flowplayer Playlist and instream() API
  # *Managing providers*: We will check for and load the appropriate streaming providers as required/specified by the ad streamer configuration

==High Level Design==

Ok, with those questions answered and out of the way, we can proceed to the detailed design of the Ad Streamer.

The following diagram illustrates the high level process that the Flowplayer Open Ad Streamer implements:

{insert diagram here}


==The Code==


===Initialising the Framework===

{{{
    // Load up the config and configure the debugger
    _vastController = new VASTController();
    _vastController.setTimeBaseline(VASTController.RELATIVE_TO_CLIP);
    _vastController.trackStreamSlices = false; 
    _vastController.startStreamSafetyMargin = 300; // needed because cuepoints at 0 for FLVs don't fire
    _vastController.initialise((new PropertyBinder(new Config(), null).copyProperties(_model.config) as Config));
    doLog("Flowplayer Open Video Ad Streamer constructed - build 0.1.1.1", Debuggable.DEBUG_ALL);
}}}

===Make sure that the Streaming Providers are Loaded===

{{{
    if(_vastController.hasProvider("rtmp")) {
         ensureProviderPluginLoaded("rtmp", "rtmp");
    }

    ..... 

    _player.loadPlugin(providerName, providerUrl, onProviderLoaded);
}}}

===Configure User Input Handlers===

{{{
    // Setup the player tracking events
    _player.onFullscreen(onFullScreen);
    _player.onFullscreenExit(onFullScreenExit);
    _player.onMute(onMuteEvent);
    _player.onUnmute(onUnmuteEvent);
    _player.onVolume(onProcessVolumeEvent);  
}}}

===Configure the Key Event Listeners===

{{{
    // Setup the critical listeners for the template loading process
    _vastController.addEventListener(TemplateEvent.LOADED, onTemplateLoaded);
    _vastController.addEventListener(TemplateEvent.LOAD_FAILED, onTemplateLoadError);

    // Setup the linear ad listeners
    _vastController.addEventListener(LinearAdDisplayEvent.STARTED, onLinearAdStarted);
    _vastController.addEventListener(LinearAdDisplayEvent.COMPLETE, onLinearAdComplete); 
    _vastController.addEventListener(LinearAdDisplayEvent.CLICK_THROUGH, onLinearAdClickThrough);           
           
    // Setup the companion display listeners
    _vastController.addEventListener(CompanionAdDisplayEvent.DISPLAY, onDisplayCompanionAd);
    _vastController.addEventListener(CompanionAdDisplayEvent.HIDE, onHideCompanionAd);

    // Decide how to handle overlay displays - if through the framework, turn it on, otherwise register the event callbacks
    _vastController.enableNonLinearAdDisplay(new DisplayProperties(this, 640, 360, 25));
    _vastController.addEventListener(OverlayAdDisplayEvent.DISPLAY, onDisplayOverlay);
    _vastController.addEventListener(OverlayAdDisplayEvent.HIDE, onHideOverlay);
    _vastController.addEventListener(OverlayAdDisplayEvent.DISPLAY_NON_OVERLAY, onDisplayNonOverlay);
    _vastController.addEventListener(OverlayAdDisplayEvent.HIDE_NON_OVERLAY, onHideNonOverlay);
    _vastController.addEventListener(OverlayAdDisplayEvent.CLICKED, onOverlayClicked);
    _vastController.addEventListener(AdNoticeDisplayEvent.DISPLAY, onDisplayNotice);
    _vastController.addEventListener(AdNoticeDisplayEvent.HIDE, onHideNotice);
          
    // Setup the hander for tracking point set events
    _vastController.addEventListener(TrackingPointEvent.SET, onSetTrackingPoint);
    _vastController.addEventListener(TrackingPointEvent.FIRED, onTrackingPointFired);
            
    // Setup the hander for display events on the seeker bar
    _vastController.addEventListener(SeekerBarEvent.TOGGLE, onToggleSeekerBar);
            
    // Ok, let's load up the VAST data from our Ad Server - when the stream sequence is constructed, register for callbacks
    _vastController.addEventListener(StreamSchedulingEvent.SCHEDULE, onStreamSchedule);
    _vastController.addEventListener(NonLinearSchedulingEvent.SCHEDULE, onNonLinearSchedule);
}}}

===Load up the VAST Data from the Ad Server===

{{{
    _vastController.load();	

    ....

    protected function onTemplateLoaded(event:TemplateEvent):void {
        doLogAndTrace("NOTIFICATION: VAST data loaded - ", event.template, Debuggable.DEBUG_FATAL);
        _player.playlist.replaceClips2(_clipList);
        _model.dispatchOnLoad();
    }
}}}

===Processing Time Based Events - Cuepoints===

{{{
    protected function processCuepoint(clipevent:ClipEvent):void {
        var cuepoint:Cuepoint = clipevent.info as Cuepoint;
        var streamIndex:int = parseInt(cuepoint.callbackId.substr(3));
        var eventCode:String = cuepoint.callbackId.substr(0,2);
        doLog("Cuepoint triggered " + clipevent.toString() + " - id: " + cuepoint.callbackId, Debuggable.DEBUG_CUEPOINT_EVENTS);
        _vastController.processTimeEvent(streamIndex, new TimeEvent(clipevent.info.time, 0, eventCode));            	            
    }
}}}


===Turning the Control Bar On and Off===

{{{
    private function setScrubber(turnOn:Boolean):void {
         var controlProps:org.flowplayer.model.DisplayProperties = _player.pluginRegistry.getPlugin("controls") as org.flowplayer.model.DisplayProperties;
         var controls:Controls = controlProps.getDisplayObject() as Controls;

         if(turnOn) {
             doLog("Turning the scrubber on", Debuggable.DEBUG_TRACKING_EVENTS);
             controls.enable({all: true, scrubber: true});		
         }	
         else {
             doLog("Turning the scrubber off", Debuggable.DEBUG_TRACKING_EVENTS);
             controls.enable({all: true, scrubber: false});		
         }
    }    
}}}